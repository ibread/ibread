#!/usr/bin/python
# @file: parse_path.py
# @author: Zhiqiu Kong <zk11@duke.edu>
# @brief: This script is used to parse the .pattern file generated by fastscan to get the useful information we need.
#             The information includes scan_chain, test pattern, forced_input, etc.
# @usage:
#
import os, sys
import re

def get_state(pat, prefix=""):
    try:
        f = open(pattern_name)
    except IOError:
        print "Error openning %s" % pattern_name
        sys.exit(1)

    results = f.readlines()

    f.close()

    flag = False
    raw_inputs = ""
    has_prefix = False
    for r in results:
        if prefix != "" and not has_prefix:
            has_prefix = prefix in r
            continue 

        if flag or pat in r:
            flag = True
            raw_inputs += r.strip()
            if r.strip().endswith(';'):
                flag = False
    return raw_inputs

def get_pins(pat):
    '''
        Given a pattern (input or ouput), return a list containing all input/output pins
        Parse from pattern file
    '''
    raw_inputs = get_state(pat)
    
    raw_inputs = raw_inputs.replace('"', '').strip(';')
    raw_inputs = raw_inputs[raw_inputs.find('=')+1:].strip()
    inputs = map(lambda x:x.strip(), raw_inputs.split(','))
    return inputs

def get_scan_chain():
    '''
        Return a list of scan chain contained in file pattern_name
    '''
    try:
        f = open(pattern_name)
    except IOError:
        print "Error openning %s" % pattern_name
        sys.exit(1)

    results = f.readlines()

    f.close()
    
    sc = []

    for r in results:
        if 'scan_cell' in r:
            print r

def get_sc_value(pat):
    '''
        Given a pattern (grp1_load/grp1_unload), return a list containing the scan chain value
        pat denotes load/unload
    '''
    raw_state = get_state(pat, 'SCAN_TEST')
    i = raw_state.find('=', raw_state.find('=')+1)
    raw_state = raw_state[i+1:].strip(' ;"')
    raw_state = raw_state.replace('\\', '')
    return list(raw_state)

def get_force_pi():
    pat = 'force   "PI"'
    raw_state = get_state(pat, 'SCAN_TEST')
    pi = re.findall(r'"(.*?)"', raw_state)
    pi = pi[1].replace('\\', '')
    return list(pi)

def parse():
    '''
        Parse verilog file
        Get {pin_name: "dev_name:dev_port"}
    '''

    pin_name_dict = {}

    try:
        fin = open(vname)
    except IOError:
        print "Error openning %s" % vname

    state = ""

    inside = False
    
    for line in fin:
        line = line.strip()
        # print "line:", line

        # we should not deal with statements in module buf1
        if line.startswith("module buf1"):
            inside = True
            continue
        elif line.startswith("endmodule"):
            inside = False
            state = ""
            continue

        if inside:
            continue

        
        # skip comments
        if not line or line.startswith('//'):
            continue
    
        state += line.strip()
        
        if not state.endswith(';'):
            continue


        if state.split()[0] not in ["buf1", "module", "input", "output", "wire"]:
            # print "*", state, "*"
           
            # sample state 
            # NAND2X1 g34598(.A (u6_mem_b1_b ), .B (n_7758), .Y (n_7832));
            # NAND2X1
            dev_type = state.split()[0]

            # g34598(.A(u6_mem_b1_b),.B(n_7758),.Y(n_7832));
            others = ''.join(state.split()[1:])

            # g34598, .A(u6_mem_b1_b),.B(n_7758),.Y(n_7832)
            results = re.findall(r'(.+?)\((.*)\)', others)
            
            if len(results) == 0:
                print "[Error] no device name in %s" % others
            
            results = results[0]

            # g34598
            dev_name = results[0]
            # .A(u6_mem_b1_b),.B(n_7758),.Y(n_7832)
            all_ports = results[1]

            results = re.findall(r'\.([^(]+)\((.+?)\)[,]*', all_ports)
            if len(results) == 0:
                print state
                print state.split()[0]
                print "[Error] no port in %s" % all_ports

            for r in results:
                pin_port = r[0]
                pin_name = r[1]
                
                if pin_name not in pin_name_dict.keys():
                    pin_name_dict[pin_name] = ["%s:%s" % (dev_name, pin_port)]
                else:
                    pin_name_dict[pin_name].append("%s:%s" % (dev_name, pin_port))

        state = ""

    #print pin_name_dict
    return pin_name_dict


def main():
    global pattern_name
    global vname
    if len(sys.argv) < 3:
        print "Usage: %s PATTERN_NAME VNAME" % sys.argv[0]
        sys.exit(1)

    pattern_name = sys.argv[1]
    vname = sys.argv[2]

    # get primary inputs
    pat = "declare input bus"
    inputs = get_pins(pat)
    # print len(inputs)

    # get primary outputs
    pat = "declare output bus"
    outputs = get_pins(pat)
    #print outputs

    #print len(get_sc_value('apply "grp1_load"'))
    #print len(get_sc_value('apply "grp1_unload"'))

    #print len(get_force_pi())
    force_value = get_force_pi()

    if len(inputs) != len(force_value):
        print "[Error] len(inputs) != len(force_value)"

    try:
        v = open(vname).readlines()
    except IOError:
        print "Error openning %s" % vname
        sys.exit(1)
    
    v = ''.join(v) 

    valid_inputs = []
    # we use inputs[i][1:] because it looks like "/input_pin"
    for i in xrange(len(inputs)):
        has_pin = re.findall(r'\([ ]*?(%s)[ ]*?\)' % inputs[i][1:], v)
        if len(has_pin) > 0:
            valid_inputs.append(1)
        else:
            valid_inputs.append(0)

    pin_name_dict = parse()

    for i in xrange(len(valid_inputs)):
        if "scan_enable" in inputs[i] or "scan_data" in inputs[i]:
            continue
        if valid_inputs[i] == 1:
            #print inputs[i][1:], pin_name_dict[inputs[i][1:]]
            for port in pin_name_dict[inputs[i][1:]]:
                # port is like "abcd:A"
                # we need it as "/abcd/A"
                port = port.replace(':', '/')
                port = "/%s" % port
                #print inputs[i][1:]
                print "add primary input -internal %s" % (port, )
                print "add pin constraint %s C%s" % (port, force_value[i])
    
    #print valid_inputs.count(1), len(valid_inputs), len(inputs)


if __name__ == "__main__":
    main()
